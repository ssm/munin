From: Jason Woods <devel@jasonwoods.me.uk>
Date: Mon, 16 Mar 2015 13:20:03 +0000
Subject: Fix broken limits - Inheritance of warning/critical now works
 correctly and does not break subsequent limits - Aliased graph fields now
 obey limits assigned to them

---
 master/lib/Munin/Master/LimitsOld.pm | 45 +++++++++++++++++++++++++-----------
 1 file changed, 31 insertions(+), 14 deletions(-)

diff --git a/master/lib/Munin/Master/LimitsOld.pm b/master/lib/Munin/Master/LimitsOld.pm
index 3303125..decafb6 100644
--- a/master/lib/Munin/Master/LimitsOld.pm
+++ b/master/lib/Munin/Master/LimitsOld.pm
@@ -161,7 +161,19 @@ sub process_limits {
     my $work_array = [];
     foreach my $workfield (
         @{munin_find_field_for_limits($config, qr/^(critical|warning)/)}) {
-        my $parent = munin_get_parent($workfield);
+        my $parent;
+        if (defined $workfield->{'graph_title'}) {
+            # Limit is defined on a service and inherits to all fields, queue it
+            $parent = $workfield;
+        } else {
+            # Limit is defined on a field, or a non-existent service
+            # Assume field, grab parent service, and verify it is valid
+            $parent = munin_get_parent($workfield);
+            if (!defined $parent->{'graph_title'}) {
+                DEBUG "[DEBUG] Ignoring work item for non-existent service: " . munin_get_node_name($parent) if ($DEBUG);
+                next;
+            }
+        }
         if (!defined $work_hash_tmp{$parent}) {
 	    $work_hash_tmp{$parent} = 1;
 	    push @$work_array, $parent;
@@ -297,7 +309,7 @@ sub process_service {
     my $hparentobj = munin_get_parent($hobj);
     my $parent     = munin_get_node_name($hobj);
     my $gparent    = munin_get_node_name($hparentobj);
-    my $children   = munin_get_children($hash);
+    my $field_order = munin_get_field_order($hash);
 
     if (!ref $hash) {
 	LOGCROAK("I was passed a non-hash!");
@@ -308,7 +320,7 @@ sub process_service {
     DEBUG "[DEBUG] processing service: $service";
 
     # Some fields that are nice to have in the plugin output
-    $hash->{'fields'} = join(' ', map {munin_get_node_name($_)} @$children);
+    $hash->{'fields'} = join(' ', @$field_order);
     $hash->{'plugin'} = $service;
     $hash->{'graph_title'} = get_full_service_name($hash);
     $hash->{'host'}  = $hostalias;
@@ -320,16 +332,26 @@ sub process_service {
     DEBUG "[DEBUG] state_file: $state_file";
     my $state = munin_read_storable($state_file) || {};
 
-    foreach my $field (@$children) {
+    my %seen = ();
+    foreach my $fname (@$field_order) {
+        # If field has an alias, strip it away and store it for use in munin_get_rrd_filename
+        my $path = undef;
+        $path = $1 if ($fname =~ s/=(.+)//);
+
+        # Field order contains duplicates sometimes, skip if already seen
+        next if (exists($seen{$fname}));
+        $seen{$fname} = 1;
+
+        my $field   = munin_get_node($hash, [$fname]);
         next if (!defined $field or ref($field) ne "HASH");
-        my $fname   = munin_get_node_name($field);
         my $fpath   = munin_get_node_loc($field);
         my $onfield = munin_get_node($oldnotes, $fpath);
 	my $oldstate= '';
 
-	# Test directly here as get_limits is in truth recursive and
-	# that fools us when processing multigraphs.
-	next if (!defined($field->{warning}) and !defined($field->{critical}));
+        my ($warn, $crit, $unknown_limit) = get_limits($field);
+
+        # Skip fields without warning/critical definitions
+        next if (!defined $warn and !defined $crit);
 
 	# get the old state if there is one, or leave it empty.
 	if ( defined($onfield) or
@@ -337,16 +359,11 @@ sub process_service {
 	    $oldstate = $onfield->{"state"};
 	}
 
-        my ($warn, $crit, $unknown_limit) = get_limits($field);
-
-        # Skip fields without warning/critical definitions
-        next if (!defined $warn and !defined $crit);
-
         DEBUG "[DEBUG] processing field: " . join('::', @$fpath);
         DEBUG "[DEBUG] field: " . munin_dumpconfig_as_str($field);
 	my $value;
     	{
-		my $rrd_filename = munin_get_rrd_filename($field);
+		my $rrd_filename = munin_get_rrd_filename($field, $path);
 		my ($current_updated_timestamp, $current_updated_value) = @{ $state->{value}{"$rrd_filename:42"}{current} || [ ] };
 		my ($previous_updated_timestamp, $previous_updated_value) = @{ $state->{value}{"$rrd_filename:42"}{previous} || [ ] };
 
